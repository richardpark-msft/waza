# Unified release workflow for Waza CLI + azd extension
# Supersedes go-release.yml and azd-ext-release.yml
#
# Triggers:
#   - Tag push matching v*.*.*
#   - Manual workflow_dispatch with version and build toggles
#
# See docs/RELEASE.md for usage details.

name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g. 1.2.3 — without v prefix)'
        required: true
        type: string
      build_cli:
        description: 'Build standalone CLI binaries'
        required: false
        type: boolean
        default: true
      build_extension:
        description: 'Build azd extension binaries'
        required: false
        type: boolean
        default: true
      publish_extension:
        description: 'Publish extension to azd registry'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write

jobs:
  # ──────────────────────────────────────────────
  # 1. Extract and validate the release version
  # ──────────────────────────────────────────────
  setup-version:
    name: Setup Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Determine Version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="${GITHUB_REF_NAME#v}"
          fi

          # Validate semver format (major.minor.patch with optional pre-release)
          if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?(\+[a-zA-Z0-9.]+)?$'; then
            echo "::error::Invalid semver: $VERSION"
            exit 1
          fi

          TAG="v${VERSION}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Releasing version: $VERSION (tag: $TAG)"

  # ──────────────────────────────────────────────
  # 2. Build standalone CLI binaries (matrix)
  # ──────────────────────────────────────────────
  build-cli:
    name: CLI ${{ matrix.os }}/${{ matrix.arch }}
    needs: setup-version
    if: inputs.build_cli != false
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - os: linux
            arch: amd64
          - os: linux
            arch: arm64
          - os: darwin
            arch: amd64
          - os: darwin
            arch: arm64
          - os: windows
            arch: amd64
          - os: windows
            arch: arm64
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache-dependency-path: go.sum

      - name: Setup Node.js (for web UI build)
        if: hashFiles('web/package.json') != ''
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Build Web UI
        if: hashFiles('web/package.json') != ''
        working-directory: web
        run: npm ci && npm run build

      - name: Build Binary
        env:
          GOOS: ${{ matrix.os }}
          GOARCH: ${{ matrix.arch }}
          CGO_ENABLED: '0'
        run: |
          VERSION="${{ needs.setup-version.outputs.version }}"
          BINARY_NAME="waza-${{ matrix.os }}-${{ matrix.arch }}"
          if [ "${{ matrix.os }}" = "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          go build \
            -ldflags "-X main.version=${VERSION}" \
            -o "${BINARY_NAME}" \
            ./cmd/waza

          echo "Built ${BINARY_NAME}"

      - name: Upload Binary Artifact
        uses: actions/upload-artifact@v4
        with:
          name: cli-waza-${{ matrix.os }}-${{ matrix.arch }}
          path: waza-${{ matrix.os }}-${{ matrix.arch }}*
          if-no-files-found: error

  # ──────────────────────────────────────────────
  # 3. Build azd extension binaries
  # ──────────────────────────────────────────────
  build-extension:
    name: Extension Build
    needs: setup-version
    if: inputs.build_extension != false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Go Environment
        uses: actions/setup-go@v5
        with:
          go-version: '1.25'
          cache-dependency-path: go.sum

      - name: Install Azure Developer CLI
        uses: Azure/setup-azd@v2

      - name: Enable azd Extensions
        run: azd config set alpha.extensions on

      - name: Install azd Extensions Developer Kit
        run: azd extension install microsoft.azd.extensions --source azd

      - name: Build Extension
        run: azd x build --all --skip-install
        env:
          VERSION: ${{ needs.setup-version.outputs.version }}

      - name: Pack Extension
        run: azd x pack -o ./artifacts
        env:
          VERSION: ${{ needs.setup-version.outputs.version }}

      - name: Upload Extension Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ext-artifacts
          path: ./artifacts/*
          if-no-files-found: error

  # ──────────────────────────────────────────────
  # 4. Create GitHub Release with all binaries
  # ──────────────────────────────────────────────
  create-release:
    name: Create Release
    needs: [setup-version, build-cli, build-extension]
    if: |
      always() &&
      needs.setup-version.result == 'success' &&
      (needs.build-cli.result == 'success' || needs.build-cli.result == 'skipped') &&
      (needs.build-extension.result == 'success' || needs.build-extension.result == 'skipped') &&
      (needs.build-cli.result == 'success' || needs.build-extension.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: Generate SHA256 Checksums
        working-directory: artifacts
        run: |
          sha256sum * > checksums.txt
          echo "Generated checksums:"
          cat checksums.txt

      - name: Create Tag (workflow_dispatch only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          TAG="${{ needs.setup-version.outputs.tag }}"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$TAG" -m "Release $TAG"
          git push origin "$TAG"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.setup-version.outputs.tag }}"
          gh release create "$TAG" \
            --repo "${{ github.repository }}" \
            --title "Waza $TAG" \
            --generate-notes \
            artifacts/*

  # ──────────────────────────────────────────────
  # 5. Publish extension to azd registry
  # ──────────────────────────────────────────────
  publish-extension:
    name: Publish Extension
    needs: [setup-version, build-extension]
    if: |
      needs.build-extension.result == 'success' &&
      (inputs.publish_extension == true || github.event_name == 'push')
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download Extension Artifacts
        uses: actions/download-artifact@v4
        with:
          name: ext-artifacts
          path: artifacts

      - name: Install Azure Developer CLI
        uses: Azure/setup-azd@v2

      - name: Enable azd Extensions
        run: azd config set alpha.extensions on

      - name: Release Extension
        run: |
          azd x release \
            --repo spboyer/waza \
            --version "$VERSION" \
            --title "Waza azd Extension v${VERSION}" \
            --notes-file "./CHANGELOG.md" \
            --artifacts "./artifacts/*.zip,./artifacts/*.tar.gz" \
            --confirm
        env:
          VERSION: ${{ needs.setup-version.outputs.version }}

      - name: Publish Extension
        run: |
          azd x publish \
            --repo spboyer/waza \
            --version "$VERSION" \
            --artifacts "./artifacts/*.zip,./artifacts/*.tar.gz" \
            --registry ./registry.json
        env:
          VERSION: ${{ needs.setup-version.outputs.version }}

      - name: Create PR with Updated Registry
        env:
          VERSION: ${{ needs.setup-version.outputs.version }}
        run: |
          if git diff --quiet registry.json 2>/dev/null; then
            echo "registry.json was not modified, skipping PR creation"
            exit 0
          fi

          BRANCH="release/ext-v${VERSION}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Delete existing remote branch if it exists (handle retries)
          git push origin --delete "$BRANCH" 2>/dev/null || true

          # Create branch from origin/main with only the registry change
          cp registry.json /tmp/registry.json
          git checkout -b "$BRANCH" origin/main
          cp /tmp/registry.json registry.json
          git add registry.json
          git commit -m "chore: Update registry.json for extension v${VERSION}"
          git push origin "$BRANCH"

          PR_URL=$(gh pr create \
            --title "chore: Update extension registry for v${VERSION}" \
            --body "## Extension Registry Update

          Automated update from the [Release](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) workflow.

          ### Changes
          - Updated \`registry.json\` with artifacts for extension version **${VERSION}**
          - Checksums and download URLs for all 6 platform targets" \
            --base main \
            --head "$BRANCH")

          echo "Created PR: $PR_URL"

          gh pr merge "$PR_URL" --squash --admin --delete-branch
          echo "Auto-merged registry PR"

  # ──────────────────────────────────────────────
  # 6. Sync version files to match the release
  # ──────────────────────────────────────────────
  sync-versions:
    name: Sync Versions
    needs: [setup-version, create-release, publish-extension]
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Sync version.txt and extension.yaml
        env:
          VERSION: ${{ needs.setup-version.outputs.version }}
        run: |
          CHANGED=false

          # Update version.txt if different
          CURRENT_TXT=$(cat version.txt 2>/dev/null || echo "")
          if [ "$CURRENT_TXT" != "$VERSION" ]; then
            echo "$VERSION" > version.txt
            CHANGED=true
            echo "Updated version.txt: $CURRENT_TXT -> $VERSION"
          fi

          # Update extension.yaml version field if different
          CURRENT_EXT=$(grep '^version:' extension.yaml | awk '{print $2}')
          if [ "$CURRENT_EXT" != "$VERSION" ]; then
            sed "s/^version: .*/version: $VERSION/" extension.yaml > extension.yaml.tmp && mv extension.yaml.tmp extension.yaml
            CHANGED=true
            echo "Updated extension.yaml: $CURRENT_EXT -> $VERSION"
          fi

          if [ "$CHANGED" = "true" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add version.txt extension.yaml
            git commit -m "chore: Sync version files to $VERSION"
            git push origin HEAD:main
            echo "Pushed version sync commit"
          else
            echo "All version files already match $VERSION"
          fi
